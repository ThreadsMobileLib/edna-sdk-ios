// Generated by Apple Swift version 4.0 effective-3.2 (swiftlang-900.0.65 clang-900.0.37)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_attribute(external_source_symbol)
# define SWIFT_STRINGIFY(str) #str
# define SWIFT_MODULE_NAMESPACE_PUSH(module_name) _Pragma(SWIFT_STRINGIFY(clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in=module_name, generated_declaration))), apply_to=any(function, enum, objc_interface, objc_category, objc_protocol))))
# define SWIFT_MODULE_NAMESPACE_POP _Pragma("clang attribute pop")
#else
# define SWIFT_MODULE_NAMESPACE_PUSH(module_name)
# define SWIFT_MODULE_NAMESPACE_POP
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR __attribute__((enum_extensibility(open)))
# else
#  define SWIFT_ENUM_ATTR
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_ATTR SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import ObjectiveC;
@import Foundation;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

SWIFT_MODULE_NAMESPACE_PUSH("PushServerAPI")

SWIFT_CLASS("_TtC13PushServerAPI15AbstractRequest")
@interface AbstractRequest : NSObject
@property (nonatomic, copy) NSURLRequest * _Nonnull request;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) BOOL useSecureBySecurityToken;
- (void)setSecurityToken:(NSString * _Nonnull)token;
@end


/// <h1>PushServerAPIResponse</h1>
/// Стандартный response от сервера (Base Class).
SWIFT_CLASS("_TtC13PushServerAPI21PushServerAPIResponse")
@interface PushServerAPIResponse : NSObject
/// Инициалиция объекта
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// При возникновение каких либо ошибок сетевого взаимодействия или некорректной передаче параметров методу,
/// <em>errorCode</em> выставляется больше <em>0</em>. Если ошибок нет, тогда либо равен <em>nil</em> либо <em>errorCode = 0</em>.
@property (nonatomic) int32_t errorCode;
/// Описание ошибки.
@property (nonatomic, copy) NSString * _Nullable errorDescription;
/// Стандартное описание объекта, наследника от <em>NSObject</em>
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Стандартное описание, для вывода информации с помощью <em>LLDB</em> дебагера.
@property (nonatomic, readonly, copy) NSString * _Nonnull debugDescription;
@end

enum PhoneNumberConfirmationStatus : NSInteger;

/// Response на запрос подтверждения телефонного номера
SWIFT_CLASS("_TtC13PushServerAPI26ConfirmPhoneNumberResponse")
@interface ConfirmPhoneNumberResponse : PushServerAPIResponse
/// Статус подтверждения телефонного номера к устройству зарегистрированному на <em>push платформе</em>.
@property (nonatomic) enum PhoneNumberConfirmationStatus confirmationStatus;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC13PushServerAPI14DeviceIdKeeper")
@interface DeviceIdKeeper : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) DeviceIdKeeper * _Nonnull shared;)
+ (DeviceIdKeeper * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getOrCreateDeviceId SWIFT_WARN_UNUSED_RESULT;
- (void)clear;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end




/// Сообщение
SWIFT_CLASS("_TtC13PushServerAPI12InOutMessage")
@interface InOutMessage : NSObject
/// Признак входящего / исходящего сообщения
@property (nonatomic, readonly) BOOL incoming;
/// Идентификатор сообщения
@property (nonatomic, readonly) int64_t messageId;
/// Время отправки (поступления на пуш платформу)
@property (nonatomic, readonly) NSTimeInterval sentAt;
/// Контент сообщения
@property (nonatomic, readonly, copy) NSString * _Nonnull content;
/// Сообщение прочитано оператором (для InMessage)
@property (nonatomic, readonly) BOOL messageRead;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC13PushServerAPI27InOutMessageHistoryResponse")
@interface InOutMessageHistoryResponse : PushServerAPIResponse
@property (nonatomic, readonly, copy) NSArray<InOutMessage *> * _Nullable messages;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// Статус подтверждения телефонного номера к устройству зарегистрированному на <em>push платформе</em>.
/// <ul>
///   <li>
///     confirmed:   Подтверждено
///   </li>
///   <li>
///     codeInvalid: Неверный код подверждения
///   </li>
///   <li>
///     codeExpired: Время жизни кода подтверждения истекло
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, PhoneNumberConfirmationStatus) {
/// Подтверждено
  PhoneNumberConfirmationStatusConfirmed = 0,
/// Неверный код подверждения
  PhoneNumberConfirmationStatusCodeInvalid = 1,
/// Время жизни кода подтверждения истекло
  PhoneNumberConfirmationStatusCodeExpired = 2,
};


SWIFT_CLASS("_TtC13PushServerAPI7Request")
@interface Request : AbstractRequest
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC13PushServerAPI12ProtoRequest")
@interface ProtoRequest : Request
- (nonnull instancetype)init:(NSDictionary<NSString *, id> * _Nonnull)bodyParameters OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) BOOL useSecureByAuthToken;
- (void)setAuthToken:(NSString * _Nonnull)token;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC13PushServerAPI23PushNotificationMessage")
@interface PushNotificationMessage : NSObject
/// Идентификатор сообщения <em>readonly</em>
@property (nonatomic, readonly, copy) NSString * _Nonnull messageId;
/// Время отправки (поступления на пуш платформу) <em>readonly</em>
@property (nonatomic, readonly) int64_t sentAt;
/// Флаг означающий что сообщение было прочитанно клиентом <em>read and write</em>
@property (nonatomic) BOOL read;
/// Сообщение было отправлено в безопасном режиме (с sessionKey) <em>readonly</em>
@property (nonatomic, readonly) BOOL secured;
/// Заголовок сообщения, отправляемый в облако <em>readonly</em>
@property (nonatomic, readonly, copy) NSString * _Nullable shortMessage;
/// Контент сообщения <em>readonly</em>
@property (nonatomic, readonly, copy) NSString * _Nullable fullMessage;
/// Сообщить на push платформу что сообщение было прочитанно, значение <em>read</em> выставляется в true и отправляется на push платформу.
/// \code
/// [message markMessageAsRead:^(PushServerAPIResponse * _Nullable error) {
///
/// }];
///
/// \endcode\param complete callback успешного/не успешного завершения операции
///
///
/// returns:
/// self
- (PushNotificationMessage * _Nonnull)markMessageAsRead:(void (^ _Nullable)(PushServerAPIResponse * _Nullable))complete SWIFT_WARN_UNUSED_RESULT;
/// Hash значение объекта.
@property (nonatomic, readonly) NSInteger hashValue;
/// Стандартное описание объекта, наследника от <em>NSObject</em>
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Стандартное описание, для вывода информации с помощью <em>LLDV</em> дебагера.
@property (nonatomic, readonly, copy) NSString * _Nonnull debugDescription;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSError;
@class UIUserNotificationSettings;

/// Основной класс <em>(singleton)</em> для работы с <em>PushServerAPI</em>.
/// Библиотека в <em>runtime</em> перехватывает вызовы методов в <em>AppDelegate</em> классе, необходимые для работы с <em>APNS</em> и отображением уведомлений на устройстве.
/// Если необходима ручная обработка событий, для этого предусмотрены соответсвующие “замыкания”.
/// <em>PushServerAPI</em> после установки <em>setEnabledPushNotificaions(true)</em>, библиотека запросит необходимые разрешения и данные устройства.
/// Разработчику необходимо добавить в <em>Info.plist</em> ключи соответствующих типов. Все параметры являются обезательными, при несоблюдение
/// требований к конфигурации, библиотека принудительно завершит приложение с ошибкой, это необходимо для отладки библиотеки во время внедрения.
/// Параметры конфигурации <em>Info.plist</em>:
/// <ul>
///   <li>
///     Ключ <em>PS_API_CONFIG</em>, тип <em>Dictionary</em>, значения:
///     <ul>
///       <li>
///         Ключ <em>PS_PROVIDER_UID</em>, тип <em>String</em>, уникальный идентификатор приложения.
///       </li>
///       <li>
///         Ключ <em>PS_URLS</em>, тип <em>Dictionary</em>, значения:
///         <ul>
///           <li>
///             Ключ <em><код сервера></em>, тип значения <em>String</em>, url сервера <a href="https://pushserver.ru">https://pushserver.ru</a>
///           </li>
///         </ul>
///       </li>
///       <li>
///         Ключ <em>PS_PRIMARY_URL</em>, тип String, значение - код из списка <em>PS_URLS</em>, например <em>pserver</em>
///       </li>
///       <li>
///         Ключ <em>PS_NEED_AUTOMATICALLY_GENERATE_DEVICE_UID</em>, тип <em>Boolean</em>, флаг необходимости сгенерировать уникальный идентифкатор устройства (<em>deviceUid</em>)
///         или он генерируется разработчиками, <em>YES</em> и <em>NO</em> соответственно.
///       </li>
///       <li>
///         Ключ <em>PUSH_MESSAGE_TYPE</em>, тип <em>String</em>, (по умолчанию отсутствует) поле, наличие значения которого приводит к тому, что при получении пуша библиотека проверяет наличие данного значиения в теле пуша, если такое значение обнаружено то пуш передаётся библиотекой в хендлер appPushMessagesReceived приложения без дальнейшей обработки пуш-уведомления.
///       </li>
///     </ul>
///   </li>
/// </ul>
/// <em>Системные требования: iOS8+, PushKit.framework</em>
/// <em>Важно:</em> Все замыкания(<em>callback</em>) вызываются в главном потоке (<em>Main Thread</em>).
SWIFT_CLASS("_TtC13PushServerAPI13PushServerAPI")
@interface PushServerAPI : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL PUSH_API_LOG_ENABLE;)
+ (BOOL)PUSH_API_LOG_ENABLE SWIFT_WARN_UNUSED_RESULT;
+ (void)setPUSH_API_LOG_ENABLE:(BOOL)newValue;
/// \code
/// Инициализация библиотеки *PushServerAPI*
///
/// ````
/// [PushServerAPI default];
/// ````
///
/// \endcode
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong, getter=default) PushServerAPI * _Nonnull default_;)
+ (PushServerAPI * _Nonnull)default SWIFT_WARN_UNUSED_RESULT;
/// Показывать или не показыватье isNetworkActivityIndicatorVisible
/// \code
/// [PushServerAPI showNetworkActivity: YES];
/// Default == NO
///
/// \endcode
+ (void)showNetworkActivity:(BOOL)show;
- (void)didRegisterForRemoteNotificationsWithDeviceToken:(NSData * _Nonnull)deviceToken;
- (void)didReceiveRemoteNotification:(NSDictionary * _Nullable)userInfo;
- (void)didReceiveLocalNotification:(NSDictionary * _Nullable)userInfo;
- (void)didReceiveRemoteNotification:(NSDictionary * _Nullable)userInfo fetchCompletionHandler:(void (^ _Nonnull)(UIBackgroundFetchResult))fetchCompletionHandler;
- (void)handleActionWithIdentifier:(NSString * _Nullable)identifier userInfo:(NSDictionary * _Nonnull)userInfo completion:(void (^ _Nonnull)(void))completion;
- (void)handleActionWithIdentifier:(NSString * _Nullable)identifier userInfo:(NSDictionary * _Nonnull)userInfo responseInfo:(NSDictionary * _Nonnull)responseInfo completion:(void (^ _Nonnull)(void))completion;
- (void)didFailToRegisterForRemoteNotificationsWithError:(NSError * _Nonnull)error;
- (void)didRegisterUserNotificationSettings:(UIUserNotificationSettings * _Nonnull)settings;
/// Обработчик изменения <em>deviceAddress</em> устройства устройства.
/// \code
/// [[PushServerAPI default] setOnDeviceAddressChanged:^(NSString * _Nullable deviceAddress) {
///
/// }];
///
/// \endcode
@property (nonatomic, copy) void (^ _Nullable onDeviceAddressChanged)(NSString * _Nullable);
/// Обработчик получения новых уведомлений от пуш платформы
/// \code
///  [[PushServerAPI default] setOnPushMessagesReceived:^(NSArray<PushNotificationMessage *> * _Nonnull messages) {
///  
///  }];
///
/// \endcode
@property (nonatomic, copy) void (^ _Nullable onPushMessagesReceived)(NSArray<PushNotificationMessage *> * _Nonnull);
/// Обработчик получения новых уведомлений (НЕ от пуш платформы). Необходимо наличие флага PUSH_MESSAGE_TYPE и установленного в нём значения.
/// \code
/// [[PushServerAPI default] setAppPushMessagesReceived:^((NSDictionary * _Nonnull) userInfo) {
///
/// }];
///
/// \endcode
@property (nonatomic, copy) void (^ _Nullable appPushMessagesReceived)(NSArray<PushNotificationMessage *> * _Nonnull);
/// Обработчик информации о сообщениях прочитанных на другом устройстве.
/// \code
/// [[PushServerAPI default] setOnPushMessagesWereRead:^(NSArray<NSString *> * _Nonnull messages) {
///
/// }];
///
/// \endcode
@property (nonatomic, copy) void (^ _Nullable onPushMessagesWereRead)(NSArray<NSString *> * _Nonnull);
/// Обработчик информации о сообщениях прочитанных на другом устройстве.
/// \code
/// [[PushServerAPI default] setOnPushMessagesWereRead:^(NSArray<NSString *> * _Nonnull messages) {
///
/// }];
///
/// \endcode
@property (nonatomic, copy) void (^ _Nullable notificationsWereChanged)(BOOL);
/// Колбек получения сообщиний об ошибках
/// \code
/// [[PushServerAPI default] setFailureBlock:^(NSString *error) {
///
/// }];
///
/// \endcode
@property (nonatomic, copy) void (^ _Nullable failureBlock)(NSString * _Nonnull);
- (NSDictionary<NSString *, NSString *> * _Nullable)getAllRelevantUrls SWIFT_WARN_UNUSED_RESULT;
- (void)setRelevantUrlForKey:(NSString * _Nonnull)key value:(NSString * _Nonnull)value;
- (void)removeRelevantUrlForKey:(NSString * _Nonnull)key;
/// DeviceAddress устройства.
@property (nonatomic, readonly, copy) NSString * _Nullable deviceAddress;
/// Уникальный идентификатор устройства. Генерируется автоматически если в <em>Info.plist</em> стоит флаг PS_NEED_AUTOMATICALLY_GENERATE_DEVICE_UID = YES, eсли PS_NEED_AUTOMATICALLY_GENERATE_DEVICE_UID = NO, тогда <em>deviceUid</em> необходимо выставить до вызова <em>setEnabledPushNotifications(true …)</em>
@property (nonatomic, copy) NSString * _Nullable deviceUid;
/// Метод для добавления суффикса для идентификатора приложения (используется в определении сертификата для отправки push-уведомлений, в случае если раньше был простой APNS-сертификат). Напр., com.xxx.voip, таким образом полный идентификатор должен совпадать с идентификатором voip-сертификата. Если метод не вызывать, будет использоваться идентификатор приложения (без суффикса). Метод необходимо вызывать в самом начале, где первый раз вызывается PushServerAPI. Напр., [[PushServerAPI default] addVoipSuffixToAppPackage: @”.voip”];.
- (void)addVoipSuffixToAppPackage:(NSString * _Nonnull)suffix;
/// Метод проверки включены ли пуш нотификации. PushServerAPI считает что пуш нотификации включены только в том случае, если <em>setEnabledPushNotificaions(true …)</em> и пользователь может их увидеть, т.е. установлено разрешение <em>UIUserNotificationTypeAlert</em>.
///
/// returns:
/// true/false Включены/Выключены уведомления на устройстве
- (BOOL)isPushNotificationsEnabled SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
/// Включение и выключение push нотификаций <em>на push платформе</em>.
/// <ul>
///   <li>
///     Если передан параметр <em>true</em> начинается регистрация устройства на push платформе.
///     После завершения вызывается <em>complete</em> замыкание.
///   </li>
///   <li>
///     Если выставляется параметр <em>false</em> устройство отписывается от получения уведомлений с push платформы.
///     После завершения вызывается complete замыкание.
///     <em>Регистрирует</em> уведомления следующих типов: <em>UIUserNotificationTypeAlert, UIUserNotificationTypeBadge, UIUserNotificationTypeSound</em>
///   </li>
/// </ul>
/// \code
/// - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
/// SwitchControllCell *cell = [tableView dequeueReusableCellWithIdentifier:@"SwitchControllCell" forIndexPath:indexPath];
/// cell.infoLabel.text = @"Enable/Disable Notifications";
/// cell.switchControl.on = [PushServerAPI isPushNotificationsEnabled];
/// [cell.switchControl addTarget:self action:@selector(changedValue:) forControlEvents:UIControlEventValueChanged];
/// return cell;
/// }
///
/// -(void)changedValue:(UISwitch *)sender {
/// [[PushServerAPI default] setEnabledPushNotificaions:sender.isOn complete:^{
/// [self.tableView reloadData];
/// }];
/// }
///
///
/// \endcodeВключение и выключение push нотификаций <em>на push платформе</em>.
/// \param enable rue/false включение/выключение уведомлений
///
/// \param complete callback успешного включение пуш уведомлений
///
- (void)setEnablePushNotifications:(BOOL)enable complete:(void (^ _Nonnull)(void))complete;
@end


@interface PushServerAPI (SWIFT_EXTENSION(PushServerAPI))
/// Метод привязки id пользователя к устройству.
/// <em>Ограничения для id пользователя</em>: размер строки от 1 до 256 символов включительно.
/// В замыкание приходит <em>PushServerAPIResponse</em>, с кодами ошибок и описанием ошибок.
/// \param clientId внешний id пользователя
///
/// \param complete callback завершения
///
- (void)setClientId:(NSString * _Nonnull)clientId complete:(void (^ _Nullable)(PushServerAPIResponse * _Nullable))complete;
@end


@interface PushServerAPI (SWIFT_EXTENSION(PushServerAPI))
/// Сервис загрузки файлов.
/// \code
/// NSString *str = [[NSBundle mainBundle] pathForResource:@"musicFile" ofType:@"mp3"];
/// NSData *data = [NSData dataWithContentsOfFile:str];
/// [[PushServerAPI default] sendFile:data fileName:@"musicFile.mp3" password:nil validityTime:600 progress:^(double uploadProgress) {
/// NSLog(@"progress : %f", uploadProgress);
/// } complete:^(NSString * _Nonnull downloadUrl) {
/// NSLog(@"%@",downloadUrl);
/// } failure:^(NSError * _Nullable error) {
/// NSLog(@"%@",error);
/// }];
///
///
/// \endcode\param data бинарные данные, обезательный параметр
///
/// \param fileName имя файла(musicFile.mp3)
///
/// \param password пароль для доступа к файлу
///
/// \param validityTime время хранения файла в секундах (необязательный параметр). По истечению этого времени файл будет недоступен. Значение 0.0 означает что файл будет доступен всегда.
///
/// \param progress callback, прогресс загрузки, возвращает значение от 0.0 до 1.0
///
/// \param complete callback, загрузка завершена. Возвращает Url для скачки файла
///
/// \param failure callback, произошла ошибка
///
- (void)sendFile:(NSData * _Nonnull)data fileName:(NSString * _Nonnull)fileName password:(NSString * _Nullable)password validityTime:(NSTimeInterval)validityTime progress:(void (^ _Nullable)(double))progress complete:(void (^ _Nullable)(NSString * _Nonnull))complete failure:(void (^ _Nullable)(NSError * _Nullable))failure;
@end

@class SendMessageResponse;

@interface PushServerAPI (SWIFT_EXTENSION(PushServerAPI))
/// Метод отправки сообщений на платформу.
/// \code
/// [[PushServerAPI default] messageSend:@"aaa" systemType:NO complete:^(SendMessageResponse * _Nullable response) {
///
/// }];
///
/// \endcode\param content тело сообщения
///
/// \param systemType true/false системное или не системное сообщение
///
/// \param complete callback о завершение операции
///
- (void)messageSend:(NSString * _Nullable)content systemType:(BOOL)systemType complete:(void (^ _Nullable)(SendMessageResponse * _Nullable))complete;
@end


@interface PushServerAPI (SWIFT_EXTENSION(PushServerAPI))
/// Сброс счетчика сообщений.
/// \code
/// [[PushServerAPI default] resetNewMessageCounter:^(PushServerAPIResponse * _Nullable error) {
///
/// }];
///
/// \endcode\param complete callback завершения сброса счетчика
///
- (void)resetNewMessageCounter:(void (^ _Nullable)(PushServerAPIResponse * _Nullable))complete;
@end


@interface PushServerAPI (SWIFT_EXTENSION(PushServerAPI))
/// Метод получения истории сообщений
/// \code
/// [[PushServerAPI default] getMessageHistory:@"sadfasd" maxCount:25 complete:^(NSString *token, InOutMessageHistoryResponse * _Nullable response) {
///
/// }];
///
///
/// \endcode\param clientId внешний айди пользователя
///
/// \param maxCount количество сообщений
///
/// \param complete callback, завершения.
///
- (void)getMessageHistory:(NSString * _Nonnull)clientId maxCount:(NSInteger)maxCount complete:(void (^ _Nullable)(NSString * _Nullable, InOutMessageHistoryResponse * _Nullable))complete;
/// Метод получения следующих сообщений из истории
/// \code
/// [[PushServerAPI default] getNextMessageHistory:@"sadfasd" maxCount:25 complete:^(NSString *token, InOutMessageHistoryResponse * _Nullable response) {
///
/// }];
///
///
/// \endcode\param clientId внешний айди пользователяю
///
/// \param maxCount количество сообщений
///
/// \param complete callback, завершения.
///
- (void)getNextMessageHistory:(NSString * _Nonnull)clientId maxCount:(NSInteger)maxCount complete:(void (^ _Nullable)(NSString * _Nullable, InOutMessageHistoryResponse * _Nullable))complete;
/// Метод получения  сообщений из истории по синкТокену:
/// \code
/// [[PushServerAPI default] getMessageHistory:@"sadfasd" maxCount:25 syncToken: @"asdfas3bb3rg" complete:^(InOutMessageHistoryResponse * _Nullable response) {
///
/// }];
///
///
/// \endcode\param clientId внешний айди пользователяю
///
/// \param maxCount количество сообщений
///
/// \param syncToken токен истории (может быть nil)
///
/// \param complete callback, завершения.
///
- (void)getMessageHistory:(NSString * _Nonnull)clientId maxCount:(NSInteger)maxCount syncToken:(NSString * _Nullable)syncToken complete:(void (^ _Nullable)(NSString * _Nullable, InOutMessageHistoryResponse * _Nullable))complete;
@end

@class SetPhoneNumberResponse;

@interface PushServerAPI (SWIFT_EXTENSION(PushServerAPI))
/// Запрос к <em>push платформе</em> на подключение телефоннного номера к данному устройству.
/// <em>Ограничения к формату телефонного номера:</em> Строка состоящая только из чисел <em>1234567890</em>, длина которой не должны превышать 15 и не менее 2 символов.
/// \code
/// [[PushServerAPI default] setPhoneNumber:@"79161111111" complete:^(SetPhoneNumberResponse * _Nullable response) {
///
/// if (response.errorCode > 0) {
/// //Error handling
/// }
///
/// if (response.requredConfirmation) {
/// [[PushServerAPI default] confirmPhoneNumber:@"000" complete:^(ConfirmPhoneNumberResponse * _Nullable confirmationResponse) {
/// if (response.errorCode > 0) {
/// //Error handling
/// }
/// }];
/// }
///
/// }];
///
///
/// \endcode\param phoneNumber телефонный номер
///
/// \param complete callback завершения
///
- (void)setPhoneNumber:(NSString * _Nonnull)phoneNumber complete:(void (^ _Nullable)(SetPhoneNumberResponse * _Nullable))complete;
/// Запрос к <em>push платформе</em> на подтверждение подключения телефоннного номера к данному устройству.
/// <em>Ограничения к коду подверждения:</em> На данный момент нет.
/// \code
/// [[PushServerAPI default] setPhoneNumber:@"79161111111" complete:^(SetPhoneNumberResponse * _Nullable response) {
///
/// if (response.errorCode > 0) {
/// //Error handling
/// }
/// if (response.requredConfirmation) {
/// [[PushServerAPI default] confirmPhoneNumber:@"000" complete:^(ConfirmPhoneNumberResponse * _Nullable confirmationResponse) {
/// if (response.errorCode > 0) {
/// //Error handling
/// }
/// }];
/// }
/// }];
///
///
/// \endcode\param code код подтверждения
///
/// \param complete callback завершения
///
- (void)confirmPhoneNumber:(NSString * _Nonnull)code complete:(void (^ _Nullable)(ConfirmPhoneNumberResponse * _Nullable))complete;
@end

@class UIViewController;

@interface PushServerAPI (SWIFT_EXTENSION(PushServerAPI))
/// Старт сценария на подключения телефонного номера к устройству.
/// \param ctrl конктроллер в котором показать сценарий
///
/// \param complete callback успешного завершения подключения телефоннного номера
///
- (void)showInputConfirmationCodeDialog:(UIViewController * _Nonnull)ctrl complete:(void (^ _Nullable)(void))complete;
@end


@interface PushServerAPI (SWIFT_EXTENSION(PushServerAPI))
/// Метод генерации SecurityToken из PushAPI 1.0
///
/// returns:
/// SecurityToken
- (NSString * _Nullable)generateSecurityToken;
/// Callback изменения SecurityToken из PushAPI 1.0
@property (nonatomic, copy) void (^ _Nullable securityTokenChanged)(NSString * _Nullable);
@end


@interface PushServerAPI (SWIFT_EXTENSION(PushServerAPI))
/// Запрос принудительной синхронизации.
/// Если есть прочитанные на другом устройстве сообщения, не полученные устройством сообщения, тогда отработают соответсвующие коллбэки:
/// <ul>
///   <li>
///     didPushMessagesReceived
///   </li>
///   <li>
///     didPushMessagesWereRead
///   </li>
/// </ul>
/// \param complete callback завершения операции
///
- (void)forceSync:(void (^ _Nullable)(PushServerAPIResponse * _Nullable))complete;
- (void)markMessageAsPushDelivered:(NSDictionary * _Nullable)userInfo complete:(void (^ _Nullable)(void))complete failure:(void (^ _Nullable)(NSString * _Nonnull))failure;
- (void)markMessageAsPushDelivered:(NSArray<NSString *> * _Nonnull)serverMessageId serverId:(NSString * _Nonnull)serverId complete:(void (^ _Nullable)(void))complete failure:(void (^ _Nullable)(NSString * _Nonnull))failure;
/// Метод помечает полученные сообщения как прочитанные пользователем.
/// \code
/// [[PushServerAPI default] markMessagesAsRead:@[self.message.messageId] complete:^(PushServerAPIResponse * _Nullable error) {
///
/// }];
///
/// \endcode\param messagesId массив Id  сообщений которые нужно пометить как прочитанные
///
/// \param complete self
///
- (void)markMessagesAsRead:(NSArray<NSString *> * _Nonnull)messagesIds complete:(void (^ _Nullable)(PushServerAPIResponse * _Nullable))complete;
/// Отправка тестового push уведомления на данное устройство.
/// \param counter тестовый счетчик, для возможности отличать сообщения
///
///
/// returns:
/// self
- (PushServerAPI * _Nonnull)testPushSend:(NSInteger)counter;
@end

@class NSBundle;

@interface PushServerAPI (SWIFT_EXTENSION(PushServerAPI))
- (NSDictionary<NSString *, NSString *> * _Nonnull)getAppBackgroundPermissions:(NSBundle * _Nonnull)bundle SWIFT_WARN_UNUSED_RESULT;
@end




SWIFT_CLASS("_TtC13PushServerAPI19SendMessageResponse")
@interface SendMessageResponse : PushServerAPIResponse
@property (nonatomic, readonly, copy) NSString * _Nullable messageId;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC13PushServerAPI20ServicesConfigurator")
@interface ServicesConfigurator : NSObject
- (NSString * _Nonnull)getServiceUrl SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, copy) NSString * _Nonnull Url;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nonnull abstractStaticUrl;)
+ (NSString * _Nonnull)abstractStaticUrl SWIFT_WARN_UNUSED_RESULT;
+ (void)setAbstractStaticUrl:(NSString * _Nonnull)value;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Response на запрос подключения телефонного номера к устройству зарегистрированному на <em>push платформе</em>.
SWIFT_CLASS("_TtC13PushServerAPI22SetPhoneNumberResponse")
@interface SetPhoneNumberResponse : PushServerAPIResponse
/// Флаг необходимости вызова подтверждения телефоннного номера.
@property (nonatomic) BOOL requredConfirmation;
/// Время жизни кода подтверждения подключения телефонного номера.
@property (nonatomic) NSTimeInterval confirmationCodeTTL;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSURLSessionTask;

SWIFT_CLASS("_TtC13PushServerAPI9Transport")
@interface Transport : NSObject
- (void)showNetworkActivity:(BOOL)show;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL TRANSPORT_LOG_ENABLE;)
+ (BOOL)TRANSPORT_LOG_ENABLE SWIFT_WARN_UNUSED_RESULT;
+ (void)setTRANSPORT_LOG_ENABLE:(BOOL)value;
- (BOOL)hasAuthToken SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong, getter=default, setter=setDefault:) Transport * _Nonnull default_;)
+ (Transport * _Nonnull)default SWIFT_WARN_UNUSED_RESULT;
+ (void)setDefault:(Transport * _Nonnull)value;
+ (NSString * _Nonnull)AUTH_TOKEN_SERVICE_KEY SWIFT_WARN_UNUSED_RESULT;
- (Transport * _Nonnull)cleanSecToken;
- (Transport * _Nonnull)cleanAuthToken;
- (NSDictionary<NSString *, id> * _Nullable)sendSyncRequest:(ProtoRequest * _Nonnull)mfmrequest error:(NSError * _Nullable * _Nullable)error failureBlock:(void (^ _Nonnull)(NSString * _Nonnull))failureBlock;
- (NSURLSessionTask * _Nullable)sendRequest:(ProtoRequest * _Nonnull)mfmrequest error:(NSError * _Nullable * _Nullable)error responseBlock:(void (^ _Nullable)(NSDictionary<NSString *, id> * _Nonnull))responseBlock failureBlock:(void (^ _Nullable)(NSString * _Nullable))failureBlock;
- (NSURLSessionTask * _Nullable)sendGETRequest:(NSString * _Nonnull)url responseBlock:(void (^ _Nullable)(NSHTTPURLResponse * _Nullable, NSData * _Nullable, NSError * _Nullable))responseBlock;
- (NSData * _Nullable)sendGETRequestSynchronious:(NSString * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
@end



SWIFT_MODULE_NAMESPACE_POP
#pragma clang diagnostic pop
